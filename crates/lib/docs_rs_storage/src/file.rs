//! Simple module to store files in database.
//!
//! docs.rs supports two ways of storing files: in a postgres database and in an S3 bucket.
//! It does not support storing files on disk because of the sheer number of files:
//! doing so would quickly run into file descriptor limits when running the web server.
//!
//! It's recommended that you use the S3 bucket in production to avoid running out of disk space.
//! However, postgres is still available for testing and backwards compatibility.

use crate::storage::non_blocking::AsyncStorage;
use anyhow::Result;
use docs_rs_mimes::detect_mime;
use docs_rs_types::CompressionAlgorithm;
use mime::Mime;
use serde_json::Value;
use std::path::{Path, PathBuf};
use tracing::instrument;

/// represents a file path from our source or documentation builds.
/// Used to return metadata about the file.
#[derive(Debug)]
pub struct FileEntry {
    pub path: PathBuf,
    pub size: u64,
}

impl FileEntry {
    pub fn mime(&self) -> Mime {
        detect_mime(&self.path)
    }
}

/// Store all files in a directory and return [[mimetype, filename]] as Json
///
/// If there is an S3 Client configured, store files into an S3 bucket;
/// otherwise, stores files into the 'files' table of the local database.
///
/// The mimetype is detected using `magic`.
///
/// Note that this function is used for uploading both sources
/// and files generated by rustdoc.
pub async fn add_path_into_database<P: AsRef<Path>>(
    storage: &AsyncStorage,
    prefix: impl AsRef<Path>,
    path: P,
) -> Result<(Vec<FileEntry>, CompressionAlgorithm)> {
    storage.store_all(prefix.as_ref(), path.as_ref()).await
}

#[instrument(skip(storage))]
pub async fn add_path_into_remote_archive<P: AsRef<Path> + std::fmt::Debug>(
    storage: &AsyncStorage,
    archive_path: &str,
    path: P,
) -> Result<(Vec<FileEntry>, CompressionAlgorithm)> {
    let (file_list, algorithm) = storage
        .store_all_in_archive(archive_path, path.as_ref())
        .await?;
    Ok((file_list, algorithm))
}

pub fn file_list_to_json(files: impl IntoIterator<Item = FileEntry>) -> Value {
    Value::Array(
        files
            .into_iter()
            .map(|info| {
                Value::Array(vec![
                    Value::String(info.mime().as_ref().to_string()),
                    Value::String(info.path.into_os_string().into_string().unwrap()),
                    Value::Number(info.size.into()),
                ])
            })
            .collect(),
    )
}
