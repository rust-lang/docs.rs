use super::{error::AxumResult, match_version};
use crate::{
    db::Pool,
    impl_axum_webpage,
    storage::PathNotFoundError,
    utils::get_correct_docsrs_style_file,
    web::{
        cache::CachePolicy, error::AxumNope, file::File as DbFile, headers::CanonicalUrl,
        MatchSemver, MetaData,
    },
    AsyncStorage,
};
use anyhow::{Context as _, Result};
use axum::{extract::Path, response::IntoResponse, Extension};
use axum_extra::headers::HeaderMapExt;
use serde::{Deserialize, Serialize};
use std::{cmp::Ordering, sync::Arc};
use tracing::instrument;

/// A source file's name and mime type
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Serialize)]
struct File {
    /// The name of the file
    name: String,
    /// The mime type of the file
    mime: String,
}

impl File {
    fn from_path_and_mime(path: &str, mime: &str) -> File {
        let (name, mime) = if let Some((dir, _)) = path.split_once('/') {
            (dir, "dir")
        } else {
            (path, mime)
        };

        Self {
            name: name.to_owned(),
            mime: mime.to_owned(),
        }
    }
}

/// A list of source files
#[derive(Debug, Clone, PartialEq, Serialize)]
struct FileList {
    metadata: MetaData,
    files: Vec<File>,
}

impl FileList {
    /// Gets FileList from a request path
    ///
    /// All paths stored in database have this format:
    ///
    /// ```text
    /// [
    ///   ["text/plain", ".gitignore"],
    ///   ["text/x-c", "src/reseeding.rs"],
    ///   ["text/x-c", "src/lib.rs"],
    ///   ["text/x-c", "README.md"],
    ///   ...
    /// ]
    /// ```
    ///
    /// This function is only returning FileList for requested directory. If is empty,
    /// it will return list of files (and dirs) for root directory. req_path must be a
    /// directory or empty for root directory.
    #[instrument(skip(conn))]
    async fn from_path(
        conn: &mut sqlx::PgConnection,
        name: &str,
        version: &str,
        version_or_latest: &str,
        folder: &str,
    ) -> Result<Option<FileList>> {
        let row = match sqlx::query!(
            "SELECT crates.name,
                    releases.version,
                    releases.description,
                    releases.target_name,
                    releases.rustdoc_status,
                    releases.files,
                    releases.default_target,
                    releases.doc_targets,
                    releases.yanked,
                    releases.doc_rustc_version
            FROM releases
            INNER JOIN crates ON crates.id = releases.crate_id
            WHERE crates.name = $1 AND releases.version = $2",
            name,
            version,
        )
        .fetch_optional(&mut *conn)
        .await?
        {
            Some(row) => row,
            None => return Ok(None),
        };

        let files = if let Some(files) = row.files {
            files
        } else {
            return Ok(None);
        };

        let mut file_list = Vec::new();
        if let Some(files) = files.as_array() {
            file_list.reserve(files.len());

            for file in files {
                if let Some(file) = file.as_array() {
                    let mime = file[0].as_str().unwrap();
                    let path = file[1].as_str().unwrap();

                    // skip .cargo-ok generated by cargo
                    if path == ".cargo-ok" {
                        continue;
                    }

                    // look only files for req_path
                    if let Some(path) = path.strip_prefix(folder) {
                        let file = File::from_path_and_mime(path, mime);

                        // avoid adding duplicates, a directory may occur more than once
                        if !file_list.contains(&file) {
                            file_list.push(file);
                        }
                    }
                }
            }

            if file_list.is_empty() {
                return Ok(None);
            }

            file_list.sort_by(|a, b| {
                // directories must be listed first
                if a.mime == "dir" && b.mime != "dir" {
                    Ordering::Less
                } else if a.mime != "dir" && b.mime == "dir" {
                    Ordering::Greater
                } else {
                    a.name.to_lowercase().cmp(&b.name.to_lowercase())
                }
            });

            Ok(Some(FileList {
                metadata: MetaData {
                    name: row.name,
                    version: row.version,
                    version_or_latest: version_or_latest.to_string(),
                    description: row.description,
                    target_name: Some(row.target_name),
                    rustdoc_status: row.rustdoc_status,
                    default_target: row.default_target,
                    doc_targets: MetaData::parse_doc_targets(row.doc_targets),
                    yanked: row.yanked,
                    rustdoc_css_file: get_correct_docsrs_style_file(&row.doc_rustc_version)?,
                },
                files: file_list,
            }))
        } else {
            Ok(None)
        }
    }
}

#[derive(Debug, Clone, Serialize)]
struct SourcePage {
    file_list: FileList,
    show_parent_link: bool,
    file: Option<File>,
    file_content: Option<String>,
    canonical_url: CanonicalUrl,
    is_latest_url: bool,
    use_direct_platform_links: bool,
}

impl_axum_webpage! {
    SourcePage = "crate/source.html",
    canonical_url = |page| Some(page.canonical_url.clone()),
    cache_policy = |page| if page.is_latest_url {
        CachePolicy::ForeverInCdn
    } else {
        CachePolicy::ForeverInCdnAndStaleInBrowser
    },
    cpu_intensive_rendering = true,
}

#[derive(Deserialize, Clone, Debug)]
pub(crate) struct SourceBrowserHandlerParams {
    name: String,
    version: String,
    #[serde(default)]
    path: String,
}

#[instrument(skip(pool, storage))]
pub(crate) async fn source_browser_handler(
    Path(SourceBrowserHandlerParams {
        mut name,
        version,
        path,
    }): Path<SourceBrowserHandlerParams>,
    Extension(storage): Extension<Arc<AsyncStorage>>,
    Extension(pool): Extension<Pool>,
) -> AxumResult<impl IntoResponse> {
    let mut conn = pool.get_async().await?;

    let v = match_version(&mut conn, &name, Some(&version)).await?;

    if let Some(new_name) = &v.corrected_name {
        // `match_version` checked against -/_ typos, so if we have a name here we should
        // use that instead
        name = new_name.to_string();
    }
    let (version, version_or_latest, is_latest_url) = match v.version {
        MatchSemver::Latest((version, _)) => (version, "latest".to_string(), true),
        MatchSemver::Exact((version, _)) => (version.clone(), version, false),
        MatchSemver::Semver((version, _)) => {
            return Ok(super::axum_cached_redirect(
                &format!("/crate/{name}/{version}/source/{path}"),
                CachePolicy::ForeverInCdn,
            )?
            .into_response());
        }
    };

    let row = sqlx::query!(
        "SELECT
            releases.archive_storage,
            (
                SELECT id
                FROM builds
                WHERE builds.rid = releases.id
                ORDER BY build_time DESC
                LIMIT 1
            ) AS latest_build_id
         FROM releases
         INNER JOIN crates ON releases.crate_id = crates.id
         WHERE
             name = $1 AND
             version = $2",
        name,
        version
    )
    .fetch_one(&mut *conn)
    .await?;

    // try to get actual file first
    // skip if request is a directory
    let blob = if !path.ends_with('/') {
        match storage
            .fetch_source_file(
                &name,
                &version,
                row.latest_build_id.unwrap_or(0),
                &path,
                row.archive_storage,
            )
            .await
            .context("error fetching source file")
        {
            Ok(blob) => Some(blob),
            Err(err) => {
                if err.is::<PathNotFoundError>() {
                    None
                } else {
                    return Err(err.into());
                }
            }
        }
    } else {
        None
    };

    let canonical_url = CanonicalUrl::from_path(format!("/crate/{name}/latest/source/{path}"));

    let (file, file_content) = if let Some(blob) = blob {
        let is_text = blob.mime.starts_with("text") || blob.mime == "application/json";
        // serve the file with DatabaseFileHandler if file isn't text and not empty
        if !is_text && !blob.is_empty() {
            let mut response = DbFile(blob).into_response();
            response.headers_mut().typed_insert(canonical_url);
            response
                .extensions_mut()
                .insert(CachePolicy::ForeverInCdnAndStaleInBrowser);
            return Ok(response);
        } else if is_text && !blob.is_empty() {
            let path = blob
                .path
                .rsplit_once('/')
                .map(|(_, path)| path)
                .unwrap_or(&blob.path);
            (
                Some(File::from_path_and_mime(path, &blob.mime)),
                String::from_utf8(blob.content).ok(),
            )
        } else {
            (None, None)
        }
    } else {
        (None, None)
    };

    let current_folder = if let Some(last_slash_pos) = path.rfind('/') {
        &path[..last_slash_pos + 1]
    } else {
        ""
    };

    let file_list = FileList::from_path(
        &mut conn,
        &name,
        &version,
        &version_or_latest,
        current_folder,
    )
    .await?
    .ok_or(AxumNope::ResourceNotFound)?;

    Ok(SourcePage {
        file_list,
        show_parent_link: !current_folder.is_empty(),
        file,
        file_content,
        canonical_url,
        is_latest_url,
        use_direct_platform_links: true,
    }
    .into_response())
}

#[cfg(test)]
mod tests {
    use crate::test::*;
    use crate::web::cache::CachePolicy;
    use kuchikiki::traits::TendrilSink;
    use reqwest::StatusCode;
    use test_case::test_case;

    fn get_file_list_links(body: &str) -> Vec<String> {
        let dom = kuchikiki::parse_html().one(body);

        dom.select(".package-menu > ul > li > a")
            .expect("invalid selector")
            .map(|el| {
                let attributes = el.attributes.borrow();
                attributes.get("href").unwrap().to_string()
            })
            .collect()
    }

    #[test_case(true)]
    #[test_case(false)]
    fn fetch_source_file_utf8_path(archive_storage: bool) {
        wrapper(|env| {
            let filename = "Â∫è.pdf";

            env.fake_release()
                .archive_storage(archive_storage)
                .name("fake")
                .version("0.1.0")
                .source_file(filename, b"some_random_content")
                .create()?;

            let web = env.frontend();
            let response = web
                .get(&format!("/crate/fake/0.1.0/source/{filename}"))
                .send()?;
            assert!(response.status().is_success());
            assert_eq!(
                response.headers().get("link").unwrap(),
                "<https://docs.rs/crate/fake/latest/source/%E5%BA%8F.pdf>; rel=\"canonical\"",
            );
            assert!(response.text()?.contains("some_random_content"));
            Ok(())
        });
    }

    #[test_case(true)]
    #[test_case(false)]
    fn fetch_source_file_content(archive_storage: bool) {
        wrapper(|env| {
            env.fake_release()
                .archive_storage(archive_storage)
                .name("fake")
                .version("0.1.0")
                .source_file("some_filename.rs", b"some_random_content")
                .create()?;
            let web = env.frontend();
            assert_success_cached(
                "/crate/fake/0.1.0/source/",
                web,
                CachePolicy::ForeverInCdnAndStaleInBrowser,
                &env.config(),
            )?;
            let response = web
                .get("/crate/fake/0.1.0/source/some_filename.rs")
                .send()?;
            assert!(response.status().is_success());
            assert_eq!(
                response.headers().get("link").unwrap(),
                "<https://docs.rs/crate/fake/latest/source/some_filename.rs>; rel=\"canonical\""
            );
            assert_cache_control(
                &response,
                CachePolicy::ForeverInCdnAndStaleInBrowser,
                &env.config(),
            );
            assert!(response.text()?.contains("some_random_content"));
            Ok(())
        });
    }

    #[test_case(true)]
    #[test_case(false)]
    fn fetch_binary(archive_storage: bool) {
        wrapper(|env| {
            env.fake_release()
                .archive_storage(archive_storage)
                .name("fake")
                .version("0.1.0")
                .source_file("some_file.pdf", b"some_random_content")
                .create()?;
            let web = env.frontend();
            let response = web.get("/crate/fake/0.1.0/source/some_file.pdf").send()?;
            assert!(response.status().is_success());
            assert_eq!(
                response.headers().get("link").unwrap(),
                "<https://docs.rs/crate/fake/latest/source/some_file.pdf>; rel=\"canonical\""
            );
            assert_eq!(
                response
                    .headers()
                    .get("content-type")
                    .unwrap()
                    .to_str()
                    .unwrap(),
                "application/pdf"
            );

            assert_cache_control(
                &response,
                CachePolicy::ForeverInCdnAndStaleInBrowser,
                &env.config(),
            );
            assert!(response.text()?.contains("some_random_content"));
            Ok(())
        });
    }

    #[test_case(true)]
    #[test_case(false)]
    fn cargo_ok_not_skipped(archive_storage: bool) {
        wrapper(|env| {
            env.fake_release()
                .archive_storage(archive_storage)
                .name("fake")
                .version("0.1.0")
                .source_file(".cargo-ok", b"ok")
                .source_file("README.md", b"hello")
                .create()?;
            let web = env.frontend();
            assert_success("/crate/fake/0.1.0/source/", web)?;
            Ok(())
        });
    }

    #[test_case(true)]
    #[test_case(false)]
    fn empty_file_list_dont_break_the_view(archive_storage: bool) {
        wrapper(|env| {
            let release_id = env
                .fake_release()
                .archive_storage(archive_storage)
                .name("fake")
                .version("0.1.0")
                .source_file("README.md", b"hello")
                .create()?;

            let path = "/crate/fake/0.1.0/source/README.md";
            let web = env.frontend();
            assert_success(path, web)?;

            env.db().conn().execute(
                "UPDATE releases
                     SET files = NULL
                     WHERE id = $1",
                &[&release_id],
            )?;

            assert_eq!(web.get(path).send()?.status(), StatusCode::NOT_FOUND);

            Ok(())
        });
    }

    #[test]
    fn latest_contains_links_to_latest() {
        wrapper(|env| {
            env.fake_release()
                .archive_storage(true)
                .name("fake")
                .version("0.1.0")
                .source_file(".cargo-ok", b"ok")
                .source_file("README.md", b"hello")
                .create()?;
            let resp = env.frontend().get("/crate/fake/latest/source/").send()?;
            assert_cache_control(&resp, CachePolicy::ForeverInCdn, &env.config());
            assert!(resp.url().as_str().ends_with("/crate/fake/latest/source/"));
            let body = String::from_utf8(resp.bytes().unwrap().to_vec()).unwrap();
            assert!(body.contains("<a href=\"/crate/fake/latest/builds\""));
            assert!(body.contains("<a href=\"/crate/fake/latest/source/\""));
            assert!(body.contains("<a href=\"/crate/fake/latest\""));
            assert!(body.contains("<a href=\"/crate/fake/latest/features\""));

            Ok(())
        });
    }

    #[test_case(true)]
    #[test_case(false)]
    fn directory_not_found(archive_storage: bool) {
        wrapper(|env| {
            env.fake_release()
                .archive_storage(archive_storage)
                .name("mbedtls")
                .version("0.2.0")
                .create()?;
            let web = env.frontend();
            assert_not_found("/crate/mbedtls/0.2.0/source/test/", web)?;
            Ok(())
        })
    }

    #[test_case(true)]
    #[test_case(false)]
    fn semver_handled(archive_storage: bool) {
        wrapper(|env| {
            env.fake_release()
                .archive_storage(archive_storage)
                .name("mbedtls")
                .version("0.2.0")
                .source_file("README.md", b"hello")
                .create()?;
            let web = env.frontend();
            assert_success("/crate/mbedtls/0.2.0/source/", web)?;
            assert_redirect_cached(
                "/crate/mbedtls/*/source/",
                "/crate/mbedtls/0.2.0/source/",
                CachePolicy::ForeverInCdn,
                web,
                &env.config(),
            )?;
            Ok(())
        })
    }

    #[test_case(true)]
    #[test_case(false)]
    fn literal_krate_description(archive_storage: bool) {
        wrapper(|env| {
            env.fake_release()
                .archive_storage(archive_storage)
                .name("rustc-ap-syntax")
                .version("178.0.0")
                .description("some stuff with krate")
                .source_file("fold.rs", b"fn foo() {}")
                .create()?;
            let web = env.frontend();
            assert_success_cached(
                "/crate/rustc-ap-syntax/178.0.0/source/fold.rs",
                web,
                CachePolicy::ForeverInCdnAndStaleInBrowser,
                &env.config(),
            )?;
            Ok(())
        })
    }

    #[test]
    fn cargo_special_filetypes_are_highlighted() {
        wrapper(|env| {
            env.fake_release()
                .name("fake")
                .version("0.1.0")
                .source_file("Cargo.toml.orig", b"[package]")
                .source_file("Cargo.lock", b"[dependencies]")
                .create()?;

            let web = env.frontend();

            let response = web
                .get("/crate/fake/0.1.0/source/Cargo.toml.orig")
                .send()?
                .text()?;
            assert!(response.contains(r#"<span class="syntax-source syntax-toml">"#));

            let response = web
                .get("/crate/fake/0.1.0/source/Cargo.lock")
                .send()?
                .text()?;
            assert!(response.contains(r#"<span class="syntax-source syntax-toml">"#));

            Ok(())
        });
    }

    #[test]
    fn dotfiles_with_extension_are_highlighted() {
        wrapper(|env| {
            env.fake_release()
                .name("fake")
                .version("0.1.0")
                .source_file(".rustfmt.toml", b"[rustfmt]")
                .create()?;

            let web = env.frontend();

            let response = web
                .get("/crate/fake/0.1.0/source/.rustfmt.toml")
                .send()?
                .text()?;
            assert!(response.contains(r#"<span class="syntax-source syntax-toml">"#));

            Ok(())
        });
    }

    #[test]
    fn json_is_served_as_rendered_html() {
        wrapper(|env| {
            env.fake_release()
                .name("fake")
                .version("0.1.0")
                .source_file("Cargo.toml", b"")
                .source_file("config.json", b"{}")
                .create()?;

            let web = env.frontend();

            let response = web.get("/crate/fake/0.1.0/source/config.json").send()?;
            assert!(response
                .headers()
                .get("content-type")
                .unwrap()
                .to_str()
                .unwrap()
                .starts_with("text/html"));

            let text = response.text()?;
            assert!(text.starts_with(r#"<!DOCTYPE html>"#));

            // file list doesn't show "../"
            assert_eq!(
                get_file_list_links(&text),
                vec!["./Cargo.toml", "./config.json"]
            );

            Ok(())
        });
    }

    #[test]
    fn root_file_list() {
        wrapper(|env| {
            env.fake_release()
                .name("fake")
                .version("0.1.0")
                .source_file("Cargo.toml", b"some_random_content")
                .source_file("folder1/some_filename.rs", b"some_random_content")
                .source_file("folder2/another_filename.rs", b"some_random_content")
                .source_file("root_filename.rs", b"some_random_content")
                .create()?;

            let web = env.frontend();
            let response = web.get("/crate/fake/0.1.0/source/").send()?;
            assert!(response.status().is_success());
            assert_cache_control(
                &response,
                CachePolicy::ForeverInCdnAndStaleInBrowser,
                &env.config(),
            );

            assert_eq!(
                get_file_list_links(&response.text()?),
                vec![
                    "./folder1/",
                    "./folder2/",
                    "./Cargo.toml",
                    "./root_filename.rs"
                ]
            );
            Ok(())
        });
    }

    #[test]
    fn child_file_list() {
        wrapper(|env| {
            env.fake_release()
                .name("fake")
                .version("0.1.0")
                .source_file("folder1/some_filename.rs", b"some_random_content")
                .source_file("folder1/more_filenames.rs", b"some_random_content")
                .source_file("folder2/another_filename.rs", b"some_random_content")
                .source_file("root_filename.rs", b"some_random_content")
                .create()?;

            let web = env.frontend();
            let response = web
                .get("/crate/fake/0.1.0/source/folder1/some_filename.rs")
                .send()?;
            assert!(response.status().is_success());
            assert_cache_control(
                &response,
                CachePolicy::ForeverInCdnAndStaleInBrowser,
                &env.config(),
            );

            assert_eq!(
                get_file_list_links(&response.text()?),
                vec!["../", "./more_filenames.rs", "./some_filename.rs"],
            );
            Ok(())
        });
    }
}
