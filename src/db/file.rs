//! Simple module to store files in database.
//!
//! docs.rs supports two ways of storing files: in a postgres database and in an S3 bucket.
//! It does not support storing files on disk because of the sheer number of files:
//! doing so would quickly run into file descriptor limits when running the web server.
//!
//! It's recommended that you use the S3 bucket in production to avoid running out of disk space.
//! However, postgres is still available for testing and backwards compatibility.

use crate::error::Result;
use crate::storage::{AsyncStorage, CompressionAlgorithm};
use mime::Mime;
use serde_json::Value;
use std::ffi::OsStr;
use std::path::{Path, PathBuf};
use tracing::instrument;

/// represents a file path from our source or documentation builds.
/// Used to return metadata about the file.
#[derive(Debug)]
pub struct FileEntry {
    pub(crate) path: PathBuf,
    pub(crate) size: u64,
}

impl FileEntry {
    pub(crate) fn mime(&self) -> Mime {
        detect_mime(&self.path).parse().unwrap()
    }
}

pub(crate) fn detect_mime(file_path: impl AsRef<Path>) -> &'static str {
    let mime = mime_guess::from_path(file_path.as_ref())
        .first_raw()
        .unwrap_or("text/plain");
    match mime {
        "text/plain" | "text/troff" | "text/x-markdown" | "text/x-rust" | "text/x-toml" => {
            match file_path.as_ref().extension().and_then(OsStr::to_str) {
                Some("md") => "text/markdown",
                Some("rs") => "text/rust",
                Some("markdown") => "text/markdown",
                Some("css") => "text/css",
                Some("toml") => "text/toml",
                Some("js") => "application/javascript",
                Some("json") => "application/json",
                _ => mime,
            }
        }
        "image/svg" => "image/svg+xml",
        _ => mime,
    }
}

/// Store all files in a directory and return [[mimetype, filename]] as Json
///
/// If there is an S3 Client configured, store files into an S3 bucket;
/// otherwise, stores files into the 'files' table of the local database.
///
/// The mimetype is detected using `magic`.
///
/// Note that this function is used for uploading both sources
/// and files generated by rustdoc.
pub async fn add_path_into_database<P: AsRef<Path>>(
    storage: &AsyncStorage,
    prefix: impl AsRef<Path>,
    path: P,
) -> Result<(Vec<FileEntry>, CompressionAlgorithm)> {
    storage.store_all(prefix.as_ref(), path.as_ref()).await
}

#[instrument(skip(storage))]
pub async fn add_path_into_remote_archive<P: AsRef<Path> + std::fmt::Debug>(
    storage: &AsyncStorage,
    archive_path: &str,
    path: P,
    public_access: bool,
) -> Result<(Vec<FileEntry>, CompressionAlgorithm)> {
    let (file_list, algorithm) = storage
        .store_all_in_archive(archive_path, path.as_ref())
        .await?;
    if public_access {
        storage.set_public_access(archive_path, true).await?;
    }
    Ok((file_list, algorithm))
}

pub(crate) fn file_list_to_json(files: impl IntoIterator<Item = FileEntry>) -> Value {
    Value::Array(
        files
            .into_iter()
            .map(|info| {
                Value::Array(vec![
                    Value::String(info.mime().as_ref().to_string()),
                    Value::String(info.path.into_os_string().into_string().unwrap()),
                    Value::Number(info.size.into()),
                ])
            })
            .collect(),
    )
}
